import{_ as e,c as n,b as l,o as s}from"./app--XYqrjBE.js";const i={};function t(r,a){return s(),n("div",null,a[0]||(a[0]=[l('<h1 id="设计范式" tabindex="-1"><a class="header-anchor" href="#设计范式"><span>设计范式</span></a></h1><h3 id="第一范式-1nf" tabindex="-1"><a class="header-anchor" href="#第一范式-1nf"><span>第一范式（1NF）</span></a></h3><p>属性不可分</p><p>即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只要数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF。</p><h3 id="第二范式-2nf" tabindex="-1"><a class="header-anchor" href="#第二范式-2nf"><span>第二范式（2NF)</span></a></h3><p>符合1NF，并且非主属性完全依赖于码。</p><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要我们设计一个主键来实现(这里的主键不包含业务逻辑)</p><h3 id="第三范式-3nf" tabindex="-1"><a class="header-anchor" href="#第三范式-3nf"><span>第三范式（3NF）</span></a></h3><p>符合2NF，并且，消除传递依赖。 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主键字段。就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放(能尽量外键join就用外键join)。很多时候，我们为了满足第三范式往往会把一张表分成多张表</p><h3 id="第四范式-4nf" tabindex="-1"><a class="header-anchor" href="#第四范式-4nf"><span>第四范式（4NF）</span></a></h3><p>要求把同一表内的多对多关系删除。</p><h3 id="第五范式-5nf" tabindex="-1"><a class="header-anchor" href="#第五范式-5nf"><span>第五范式（5NF）</span></a></h3><p>从最终结构重新建立原始结构。</p>',13)]))}const p=e(i,[["render",t],["__file","paradigm.html.vue"]]),d=JSON.parse('{"path":"/mysql/notes/paradigm.html","title":"设计范式","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"第一范式（1NF）","slug":"第一范式-1nf","link":"#第一范式-1nf","children":[]},{"level":3,"title":"第二范式（2NF)","slug":"第二范式-2nf","link":"#第二范式-2nf","children":[]},{"level":3,"title":"第三范式（3NF）","slug":"第三范式-3nf","link":"#第三范式-3nf","children":[]},{"level":3,"title":"第四范式（4NF）","slug":"第四范式-4nf","link":"#第四范式-4nf","children":[]},{"level":3,"title":"第五范式（5NF）","slug":"第五范式-5nf","link":"#第五范式-5nf","children":[]}],"git":{"updatedTime":1691424102000,"contributors":[{"name":"wsafight","email":"984292420@qq.com","commits":1}]},"filePathRelative":"mysql/notes/paradigm.md"}');export{p as comp,d as data};
